package main

import "os"

/*
GoにはJavaのような例外処理はありません。例外を投げないのです。
その代わり、panicとrecoverを使用します。ぜひ覚えておいてください、これは最後の手段として使うことを。
つまり、あなたのコードにあってはなりません。
もしくはpanicを極力減らしてください。
これは非常に強力なツールです。賢く使ってください。
では、どのように使うのでしょうか？
 */

/*
Panic
>ビルトイン関数。オリジナルの処理フローを中断させることができます。
パニックが発生するフローの仲に入って関数Fがpanicをコールします。
このプロセスは継続して実行されます。一旦panicのgoruntineが発生すると、コールされた関数がすべて返ります。
この時プログラムを抜けます。パニックは直接panicをコールします。実行時にエラーを発生させても構いません。


ぜんぜんわからん！

>
 */

/*
Recover
>ビルトイン関数。パニックを発生させるフローのgoroutineを復元することができます。
recoverは遅延関数の中でのみ有効です。通常の実行中,recoverをコールするとnilが帰ります。
他にはなんの効果もありません。もし現在のgoroutineがパニックに陥ったらrecoverをコールして、
panicの入力値を補足し、正常な実行に復元することができます。

ぜんぜんわからん！

 */


/*
 panicの使い方のサンプル
 */
var user = os.Getenv("USER")

func init() {
	if user == "" {
		panic("no value for $USER")
	}
}


func throwsPanic(f func()) (b bool) {
	defer func() { // 無名関数できるんだね
		if x := recover(); x != nil {
			b = true
		}
	}() //TODO: このラストの()ってなに

	f() //関数fを実行します。もしfの仲でpanicが出現したら、復元を行うことができます
	return

}
